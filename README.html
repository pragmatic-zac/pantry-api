<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            padding-top: 0;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Before running the application you will need a working PostgreSQL installation and a valid DSN (data source name) for connecting to the database.</p>
<p>Please open the <code>cmd/api/main.go</code> file and edit the <code>db-dsn</code> command-line flag to include your valid DSN as the default value.</p>
<pre><code>
flag.StringVar(&amp;cfg.db.dsn, "db-dsn", "YOUR DSN GOES HERE", "postgreSQL DSN")
</code></pre>
<p>Note that this DSN must be in the format <code>user:pass@localhost:port/db</code> and <strong>not</strong> be prefixed with <code>postgres://</code>.</p>
<p>Make sure that you're in the root of the project directory, fetch the dependencies with <code>go mod tidy</code>, then run the application using <code>go run ./cmd/api</code>:</p>
<pre><code>
$ go mod tidy
$ go run ./cmd/api
</code></pre>
<p>If you make a request to the <code>GET /status</code> endpoint using <code>curl</code> you should get a response like this:</p>
<pre><code>
$ curl -ik https://localhost:4444/status
<samp>HTTP/2 200 
content-type: application/json
content-length: 23
date: Mon, 09 May 2022 20:48:13 GMT

{
    "Status": "OK",
}</samp></code></pre>
<p>Note: make sure to use the <code>-k</code> flag to accept self-signed TLS certificates.</p>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>assets</code></strong></td>
<td>Contains the non-code assets for the application.</td>
</tr>
<tr>
<td><code>↳ assets/migrations/</code></td>
<td>Contains SQL migrations.</td>
</tr>
<tr>
<td><code>↳ assets/efs.go</code></td>
<td>Declares an embedded filesystem containing all the assets.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>cmd/api</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/api/context.go</code></td>
<td>Contains helpers for working with request context.</td>
</tr>
<tr>
<td><code>↳ cmd/api/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/api/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/api/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/api/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/api/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/database/</code></td>
<td>Contains your database-related code (setup, connection and queries).</td>
</tr>
<tr>
<td><code>↳ internal/password/</code></td>
<td>Contains helper functions for hashing and verifying passwords.</td>
</tr>
<tr>
<td><code>↳ internal/leveledlog/</code></td>
<td>Contains a leveled logger implementation.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding JSON requests.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for sending JSON responses.</td>
</tr>
<tr>
<td><code>↳ internal/server/</code></td>
<td>Contains a helper function for starting and gracefully shutting down the server.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>tls</code></strong></td>
<td>Contains TLS certificates.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via command-line flags in <code>main.go</code>.</p>
<p>You can try this out by using the <code>-addr</code> flag to configure the network address that the server is listening:</p>
<pre><code>
$ go run ./cmd/api --addr=:9999
</code></pre>
<p>Feel free to adapt the <code>main()</code> function to parse additional command-line flags and store their values in the <code>config</code> struct. For example, to add a configuration setting to enable a 'debug mode' in your application you could do this:</p>
<pre><code>
type config struct {
    addr string
    debug bool
}

...

func main() {
    var cfg config

    flag.StringVar(&amp;cfg.addr, "addr", ":4444", "server address")
    flag.BoolVar(&amp;cfg.debug, "debug", false, "enable debug mode")

    flag.Parse()

    ...
}
</code></pre>
<p>If you don't want to use command-line flags for configuration that's fine. Feel free to adapt the code so that the <code>config</code> struct is populated from environment variables or a settings file instead.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</code></pre>
<p>Handlers are defined in the <code>cmd/api/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>main()</code> function <code>cmd/api/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/api/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/go-chi/chi">chi</a> version 5 is used for routing, but it's fine to swap to a different router if you want.</p>
<p>Routes are defined in the <code>routes()</code> method in the <code>cmd/api/routes.go</code> file. For example:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    
    mux.Get("/your/path", app.yourHandler)
    
    return mux
}
</code></pre>
<p>For more information about chi and example usage, please see the <a href="https://github.com/go-chi/chi">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/api/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre><code>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</code></pre>
<p>You can then register this middleware with the router using the <code>Use()</code> method:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)
    
    mux.Get("/your/path", app.yourHandler)
    
    return mux
}
</code></pre>
<p>It's possible to use middleware on specific routes only by creating route 'groups':</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)
    
    mux.Get("/your/path", app.yourHandler)

    mux.Group(func(mux chi.Router) {
        mux.Use(app.yourOtherMiddleware)
    
        mux.Get("/your/other/path", app.yourOtherHandler)
    })
    
    return mux
}
</code></pre>
<p>Note: Route 'groups' can also be nested.</p>
<h2>Sending JSON responses</h2>
<p>JSON responses and a specific HTTP status code can be sent using the <code>response.JSON()</code> function. The <code>data</code> parameter can be any JSON-marshalable type.</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<h2>Parsing JSON requests</h2>
<p>HTTP requests containing a JSON body can be decoded using the <code>request.DecodeJSON()</code> function. For example, to decode JSON into an <code>input</code> struct:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }
    
    ...
}
</code></pre>
<p>Note: The target decode destination passed to <code>request.DecodeJSON()</code> (which in the example above is <code>&amp;input</code>) must be a non-nil pointer.</p>
<p>The <code>request.DecodeJSON()</code> function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the <code>app.badRequest()</code> helper.</p>
<h2>Validating JSON requests</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age &gt;= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}    
</code></pre>
<p>The <code>app.failedValidation()</code> helper will send a <code>422</code> status code along with any validation error messages. For the example above, the JSON response will look like this:</p>
<pre><code>
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}    
</code></pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre><code>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</code></pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre><code>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</code></pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre><code>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</code></pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Working with the database</h2>
<p>This codebase is set up to use PostgreSQL with the <a href="https://github.com/lib/pq">lib/pq</a> driver. You can control which database you connect to using the <code>-db-dsn</code> command-line flag when starting the application to pass in a DSN, or by adapting the default value in <code>main()</code>.</p>
<p>The codebase is also configured to use <a href="https://github.com/jmoiron/sqlx">jmoiron/sqlx</a>, so you have access to the whole range of sqlx extensions as well as the standard library <code>Exec()</code>, <code>Query()</code> and <code>QueryRow()</code> methods .</p>
<p>The database is available to your handlers, middleware and helpers via the <code>application</code> struct. If you want, you can access the database and carry out queries directly. For example:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", "Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</code></pre>
<p>Generally though, it's recommended to isolate your database logic in the <code>internal/database</code> package and extend the <code>DB</code> type to include your own methods. For example, you could create a <code>internal/database/people.go</code> file containing code like:</p>
<pre><code>
type Person struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Age   int    `db:"age"`
}

func (db *DB) NewPerson(name string, age int) error {
    _, err := db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", name, age)
    return err
}

func (db *DB) GetPerson(id int) (Person, error) {
    var person Person
    err := db.Get(&amp;person, "SELECT * FROM people WHERE id = $1", id)
    return person, err
}
</code></pre>
<p>And then call this from your handlers:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.NewPerson("Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</code></pre>
<h2>Managing SQL migrations</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily create and work with database migrations:</p>
<table>
<tbody>
<tr>
<td><code>$ make migrations/new name=add_example_table</code></td>
<td>Create a new database migration in the <code>assets/migrations</code> folder.</td>
</tr>
<tr>
<td><code>$ make migrations/up</code></td>
<td>Apply all up migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/down</code></td>
<td>Apply all down migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/goto version=N</code></td>
<td>Migrate up or down to a specific migration (where N is the migration version number).</td>
</tr>
<tr>
<td><code>$ make migrations/force version=N</code></td>
<td>Force the database to be specific version without running any migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/version</code></td>
<td>Display the currently in-use migration version.</td>
</tr>
</tbody>
</table>
<p>Hint: You can run <code>$ make help</code> at any time for a reminder of these commands.</p>
<p>These <code>Makefile</code> tasks are simply wrappers around calls to the <code>github.com/golang-migrate/migrate/v4/cmd/migrate</code> tool. For more information, please see the <a href="https://github.com/golang-migrate/migrate/tree/master/cmd/migrate">official documentation</a>.</p>
<p>By default all 'up' migrations are automatically run on application startup using embeded files from the <code>assets/migrations</code> directory. You can disable this by using the command-line flag <code>-db-automigrate=false</code> when running the application.</p>
<h2>Logging</h2>
<p>The <code>internal/leveledlog</code> package provides a leveled-logger implementation. It outputs color-coded log lines in the following format:</p>
<pre><code>
level="INFO" time="2022-08-15T08:51:09+02:00" message="starting server on localhost:4444 (version 0.0.1)"
</code></pre>
<p>By default, a logger is initialized in the <code>main()</code> function which writes all log messages to <code>os.Stdout</code>. You can call the logger's <code>Info()</code>, <code>Warn()</code>, <code>Error()</code> and <code>Fatal()</code> methods to log messages at different levels with <code>fmt.Printf</code> style formatting. For example:</p>
<pre><code>
logger.Info("starting server on port %d", 1234)
</code></pre>
<p>Note: Stack traces are automatically appended to <code>Error()</code> and <code>Fatal()</code> messages, and calling <code>Fatal()</code> will cause your application to terminate.</p>
<p>If you want to disable the color-coding, then pass <code>false</code> as the final parameter when initializing the logger in <code>main()</code>.</p>
<pre><code>
logger := leveledlog.NewLogger(os.Stdout, leveledlog.LevelAll, false)
</code></pre>
<p>You can also write JSON-formated log entries instead by using the <code>NewJSONLogger()</code> function to initialize the logger:</p>
<pre><code>
logger := leveledlog.NewJSONLogger(os.Stdout, leveledlog.LevelAll)
</code></pre>
<p>Note: JSON-formatted log entries are not color-coded.</p>
<p>Feel free to adapt the <code>internal/leveledlog</code> package to change this behavior or include additional fields if you want.</p>
<h2>Using Basic Authentication</h2>
<p>The <code>cmd/api/middleware.go</code> file contains a <code>basicAuth</code> middleware that you can use to protect your application — or specific application routes — with HTTP basic authentication.</p>
<p>You can try this out by visiting the <a href="https://localhost:4444//basic-auth-protected">https://localhost:4444//basic-auth-protected</a> endpoint in any web browser and entering the default user name and password:</p>
<pre><code>
User name: admin
Password:  pa55word
</code></pre>
<p>You can change the user name and password by passing <code>-auth-username</code> and <code>-auth-hashed-password</code> command-line flags when starting the application. For example:</p>
<pre><code>
$ go run ./cmd/api --auth-username='alice' --auth-hashed-password='$2a$10$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
</code></pre>
<p>Note: You will probably need to wrap the username and password in <code>'</code> quotes to prevent your shell interpreting dollar and slash symbols as special characters.</p>
<p>The value for <code>-auth-hashed-password</code> should be a bcrypt hash of the password, not the plaintext password itself. An easy way to generate the bcrypt hash for a password is to use the <code>gophers.dev/cmds/bcrypt-tool</code> package like so:</p>
<pre><code>
$ go run gophers.dev/cmds/bcrypt-tool@latest hash 'your_pa55word'
</code></pre>
<p>If you want to change the default values for username and password you can do so by editing the default command-line flag values in the <code>cmd/api/main.go</code> file.</p>
<h2>User accounts</h2>
<p>The application is configured to support user accounts with fully-functional signup and authentication workflows.</p>
<p>A <code>User</code> struct describing the data for a user is defined in <code>internal/database/users.go</code>.</p>
<pre><code>
type User struct {
    ID             int       `db:"id"`
    Created        time.Time `db:"created"`
    Email          string    `db:"email"`
    HashedPassword string    `db:"hashed_password"`
}
</code></pre>
<p>Feel free to add additional fields to this struct (don't forget to also update the SQL queries, migrations, and handler code as necessary!).</p>
<p>A new user account can be created by sending a request to the <code>POST /users</code> endpoint:</p>
<pre><code>
$ curl -ik -d '{"Email": "alice@example.com", "Password": "sectr3t_pa55word"}' https://localhost:4444/users
<samp>HTTP/1.1 204 No Content
Vary: Authorization
Date: Wed, 17 Aug 2022 05:18:12 GMT</samp>
</code></pre>
<p>Authentication is managed using stateless tokens. When running the application you should use your own secret key for signing the tokens. This key should be a random 32-character string generated using a CSRNG which you pass to the application using the <code>-jwt-secret</code> command-line flag:</p>
<pre><code>
$ go run ./cmd/api --jwt-secret-key=a1uiBXkmY03pxXok3OkFV39saE8Cn574
</code></pre>
<p>A new authentication token can be created by sending the user's email and password to the <code>POST /authentication-tokens</code> endpoint.</p>
<pre><code>
$ curl -ik -d '{"Email": "alice@example.com", "Password": "sectr3t_pa55word"}' https://localhost:4444/authentication-tokens
<samp>HTTP/1.1 200 OK
Content-Type: application/json
Vary: Authorization
Date: Wed, 17 Aug 2022 05:26:02 GMT
Content-Length: 353

{
    "AuthenticationToken": "eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjQ0NDQiLCJzdWIiOiIxIiwiYXVkIjpbImh0dHA6Ly9sb2NhbGhvc3Q6NDQ0NCJdLCJleHAiOjE2NjA4MDAzNjIuMjc0MDU2MiwibmJmIjoxNjYwNzEzOTYyLjI3NDA1NjcsImlhdCI6MTY2MDcxMzk2Mi4yNzQwNTY0fQ.t469-8hrwyZUN8gWmK5TeelXgstFnwBaoW977F2JbrE",
    "AuthenticationTokenExpiry": "2022-08-18T07:26:02+02:00"
}</samp>
</code></pre>
<p>The authentication token is a JWT containing the user's ID. By default authentication tokens are valid for 24 hours. You can change this by editing the code in the <code>createAuthenticationToken</code> handler.</p>
<p>Subsequent requests to the API should include the authentication token in a HTTP <code>Authorization</code> header in the following format:</p>
<pre><code>
Authorization: Bearer &lt;authentication token&gt;
</code></pre>
<p>The <code>authenticate</code> middleware is used to check for the presence of an <code>Authorization</code> header. If the token is valid, the token is decoded and the user information is fetched from the database. You can retrieve the details of the current user in your application handlers by calling the <code>contextGetAuthenticatedUser()</code> helper.</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    authenticatedUser := contextGetAuthenticatedUser(r)
    
    ...
}
</code></pre>
<p>If an <code>Authorization</code> header is provided with a request but it is invalid or expired, then the <code>authenticate</code> middleware will return a <code>401 Unauthorized</code> response and an error message to the client.</p>
<p>If no <code>Authorization</code> header is provided, then the request is coming from an unauthenticated client. In this case, the <code>authenticate</code> middleware <em>will not</em> return an error, but calls to the <code>contextGetAuthenticatedUser()</code> helper function will return <code>nil</code>.</p>
<p>You can restrict access to specific handlers based on whether a request is coming from an authenticated client by using the <code>requireAuthenticatedUser</code> middleware. An example of using this can be seen in the <code>cmd/app/routes.go</code> file.</p>
<p>Important: You should only call the <code>requireAuthenticatedUser</code> middleware <em>after</em> the <code>authenticate</code> middleware.</p>
<h2>Admin tasks</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily run common admin tasks:</p>
<table>
<tbody>
<tr>
<td><code>$ make tidy</code></td>
<td>Format all code using <code>go fmt</code> and tidy the <code>go.mod</code> file.</td>
</tr>
<tr>
<td><code>$ make audit</code></td>
<td>Run <code>go vet</code>, <code>staticheck</code>, execute all tests and verify required modules.</td>
</tr>
<tr>
<td><code>$ make build</code></td>
<td>Build a binary for the <code>cmd/api</code> application and store it in the <code>bin</code> folder.</td>
</tr>
<tr>
<td><code>$ make run</code></td>
<td>Build and then run a binary for the <code>cmd/api</code> application.</td>
</tr>
</tbody>
</table>
<h2>Changing the TLS certificates</h2>
<p>For convenience a self-signed TLS certificate (<code>cert.pem</code>) and private key (<code>key.pem</code>) are provided in the <code>tls</code> directory.</p>
<p>You can specify a different certificate and key at runtime using the <code>tls-cert-file</code> and <code>tls-key-file</code> command-line flags.</p>
<pre><code>
$ go run . --tls-cert-file=/path/to/cert.pem --tls-key-file=/path/to/key.pem
</code></pre>
<h2>Application version</h2>
<p>The application version number is generated automatically based on your latest version control system revision number. If you are using Git, this will be your latest Git commit hash. It can be retrieved by calling the <code>version.Get()</code> function from the <code>internal/version</code> package.</p>
<p>Important: The version control system revision number will only be available when the application is built using <code>go build</code>. If you run the application using <code>go run</code> then <code>version.Get()</code> will return the string <code>"unavailable"</code>.</p>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>github.com/zacjones91/pantry-api</code>. If you want to change this please find and replace all instances of <code>github.com/zacjones91/pantry-api</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
HTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Routing
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Handlers
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
